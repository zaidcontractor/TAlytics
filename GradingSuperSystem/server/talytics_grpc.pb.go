// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: talytics.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
	GetProfile(ctx context.Context, in *GetProfileRequest, opts ...grpc.CallOption) (*UserResponse, error)
	VerifyToken(ctx context.Context, in *VerifyTokenRequest, opts ...grpc.CallOption) (*UserResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, "/talytics.UserService/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, "/talytics.UserService/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, "/talytics.UserService/Logout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetProfile(ctx context.Context, in *GetProfileRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, "/talytics.UserService/GetProfile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) VerifyToken(ctx context.Context, in *VerifyTokenRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, "/talytics.UserService/VerifyToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	Register(context.Context, *RegisterRequest) (*AuthResponse, error)
	Login(context.Context, *LoginRequest) (*AuthResponse, error)
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	GetProfile(context.Context, *GetProfileRequest) (*UserResponse, error)
	VerifyToken(context.Context, *VerifyTokenRequest) (*UserResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) Register(context.Context, *RegisterRequest) (*AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedUserServiceServer) Login(context.Context, *LoginRequest) (*AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUserServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedUserServiceServer) GetProfile(context.Context, *GetProfileRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfile not implemented")
}
func (UnimplementedUserServiceServer) VerifyToken(context.Context, *VerifyTokenRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyToken not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.UserService/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.UserService/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.UserService/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.UserService/GetProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetProfile(ctx, req.(*GetProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_VerifyToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).VerifyToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.UserService/VerifyToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).VerifyToken(ctx, req.(*VerifyTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "talytics.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _UserService_Register_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _UserService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _UserService_Logout_Handler,
		},
		{
			MethodName: "GetProfile",
			Handler:    _UserService_GetProfile_Handler,
		},
		{
			MethodName: "VerifyToken",
			Handler:    _UserService_VerifyToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talytics.proto",
}

// CourseServiceClient is the client API for CourseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CourseServiceClient interface {
	CreateCourse(ctx context.Context, in *CreateCourseRequest, opts ...grpc.CallOption) (*CourseResponse, error)
	GetCourse(ctx context.Context, in *GetCourseRequest, opts ...grpc.CallOption) (*CourseResponse, error)
	ListCourses(ctx context.Context, in *ListCoursesRequest, opts ...grpc.CallOption) (*ListCoursesResponse, error)
	UpdateCourse(ctx context.Context, in *UpdateCourseRequest, opts ...grpc.CallOption) (*CourseResponse, error)
	JoinCourse(ctx context.Context, in *JoinCourseRequest, opts ...grpc.CallOption) (*CourseResponse, error)
	LeaveCourse(ctx context.Context, in *LeaveCourseRequest, opts ...grpc.CallOption) (*LeaveCourseResponse, error)
	DeleteCourse(ctx context.Context, in *DeleteCourseRequest, opts ...grpc.CallOption) (*DeleteCourseResponse, error)
}

type courseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCourseServiceClient(cc grpc.ClientConnInterface) CourseServiceClient {
	return &courseServiceClient{cc}
}

func (c *courseServiceClient) CreateCourse(ctx context.Context, in *CreateCourseRequest, opts ...grpc.CallOption) (*CourseResponse, error) {
	out := new(CourseResponse)
	err := c.cc.Invoke(ctx, "/talytics.CourseService/CreateCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *courseServiceClient) GetCourse(ctx context.Context, in *GetCourseRequest, opts ...grpc.CallOption) (*CourseResponse, error) {
	out := new(CourseResponse)
	err := c.cc.Invoke(ctx, "/talytics.CourseService/GetCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *courseServiceClient) ListCourses(ctx context.Context, in *ListCoursesRequest, opts ...grpc.CallOption) (*ListCoursesResponse, error) {
	out := new(ListCoursesResponse)
	err := c.cc.Invoke(ctx, "/talytics.CourseService/ListCourses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *courseServiceClient) UpdateCourse(ctx context.Context, in *UpdateCourseRequest, opts ...grpc.CallOption) (*CourseResponse, error) {
	out := new(CourseResponse)
	err := c.cc.Invoke(ctx, "/talytics.CourseService/UpdateCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *courseServiceClient) JoinCourse(ctx context.Context, in *JoinCourseRequest, opts ...grpc.CallOption) (*CourseResponse, error) {
	out := new(CourseResponse)
	err := c.cc.Invoke(ctx, "/talytics.CourseService/JoinCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *courseServiceClient) LeaveCourse(ctx context.Context, in *LeaveCourseRequest, opts ...grpc.CallOption) (*LeaveCourseResponse, error) {
	out := new(LeaveCourseResponse)
	err := c.cc.Invoke(ctx, "/talytics.CourseService/LeaveCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *courseServiceClient) DeleteCourse(ctx context.Context, in *DeleteCourseRequest, opts ...grpc.CallOption) (*DeleteCourseResponse, error) {
	out := new(DeleteCourseResponse)
	err := c.cc.Invoke(ctx, "/talytics.CourseService/DeleteCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CourseServiceServer is the server API for CourseService service.
// All implementations must embed UnimplementedCourseServiceServer
// for forward compatibility
type CourseServiceServer interface {
	CreateCourse(context.Context, *CreateCourseRequest) (*CourseResponse, error)
	GetCourse(context.Context, *GetCourseRequest) (*CourseResponse, error)
	ListCourses(context.Context, *ListCoursesRequest) (*ListCoursesResponse, error)
	UpdateCourse(context.Context, *UpdateCourseRequest) (*CourseResponse, error)
	JoinCourse(context.Context, *JoinCourseRequest) (*CourseResponse, error)
	LeaveCourse(context.Context, *LeaveCourseRequest) (*LeaveCourseResponse, error)
	DeleteCourse(context.Context, *DeleteCourseRequest) (*DeleteCourseResponse, error)
	mustEmbedUnimplementedCourseServiceServer()
}

// UnimplementedCourseServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCourseServiceServer struct {
}

func (UnimplementedCourseServiceServer) CreateCourse(context.Context, *CreateCourseRequest) (*CourseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCourse not implemented")
}
func (UnimplementedCourseServiceServer) GetCourse(context.Context, *GetCourseRequest) (*CourseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCourse not implemented")
}
func (UnimplementedCourseServiceServer) ListCourses(context.Context, *ListCoursesRequest) (*ListCoursesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCourses not implemented")
}
func (UnimplementedCourseServiceServer) UpdateCourse(context.Context, *UpdateCourseRequest) (*CourseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCourse not implemented")
}
func (UnimplementedCourseServiceServer) JoinCourse(context.Context, *JoinCourseRequest) (*CourseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinCourse not implemented")
}
func (UnimplementedCourseServiceServer) LeaveCourse(context.Context, *LeaveCourseRequest) (*LeaveCourseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveCourse not implemented")
}
func (UnimplementedCourseServiceServer) DeleteCourse(context.Context, *DeleteCourseRequest) (*DeleteCourseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCourse not implemented")
}
func (UnimplementedCourseServiceServer) mustEmbedUnimplementedCourseServiceServer() {}

// UnsafeCourseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CourseServiceServer will
// result in compilation errors.
type UnsafeCourseServiceServer interface {
	mustEmbedUnimplementedCourseServiceServer()
}

func RegisterCourseServiceServer(s grpc.ServiceRegistrar, srv CourseServiceServer) {
	s.RegisterService(&CourseService_ServiceDesc, srv)
}

func _CourseService_CreateCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CourseServiceServer).CreateCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.CourseService/CreateCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CourseServiceServer).CreateCourse(ctx, req.(*CreateCourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CourseService_GetCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CourseServiceServer).GetCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.CourseService/GetCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CourseServiceServer).GetCourse(ctx, req.(*GetCourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CourseService_ListCourses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCoursesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CourseServiceServer).ListCourses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.CourseService/ListCourses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CourseServiceServer).ListCourses(ctx, req.(*ListCoursesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CourseService_UpdateCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CourseServiceServer).UpdateCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.CourseService/UpdateCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CourseServiceServer).UpdateCourse(ctx, req.(*UpdateCourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CourseService_JoinCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinCourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CourseServiceServer).JoinCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.CourseService/JoinCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CourseServiceServer).JoinCourse(ctx, req.(*JoinCourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CourseService_LeaveCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveCourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CourseServiceServer).LeaveCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.CourseService/LeaveCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CourseServiceServer).LeaveCourse(ctx, req.(*LeaveCourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CourseService_DeleteCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CourseServiceServer).DeleteCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.CourseService/DeleteCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CourseServiceServer).DeleteCourse(ctx, req.(*DeleteCourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CourseService_ServiceDesc is the grpc.ServiceDesc for CourseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CourseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "talytics.CourseService",
	HandlerType: (*CourseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCourse",
			Handler:    _CourseService_CreateCourse_Handler,
		},
		{
			MethodName: "GetCourse",
			Handler:    _CourseService_GetCourse_Handler,
		},
		{
			MethodName: "ListCourses",
			Handler:    _CourseService_ListCourses_Handler,
		},
		{
			MethodName: "UpdateCourse",
			Handler:    _CourseService_UpdateCourse_Handler,
		},
		{
			MethodName: "JoinCourse",
			Handler:    _CourseService_JoinCourse_Handler,
		},
		{
			MethodName: "LeaveCourse",
			Handler:    _CourseService_LeaveCourse_Handler,
		},
		{
			MethodName: "DeleteCourse",
			Handler:    _CourseService_DeleteCourse_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talytics.proto",
}

// AssignmentServiceClient is the client API for AssignmentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AssignmentServiceClient interface {
	CreateAssignment(ctx context.Context, in *CreateAssignmentRequest, opts ...grpc.CallOption) (*AssignmentResponse, error)
	GetAssignment(ctx context.Context, in *GetAssignmentRequest, opts ...grpc.CallOption) (*AssignmentResponse, error)
	ListAssignments(ctx context.Context, in *ListAssignmentsRequest, opts ...grpc.CallOption) (*ListAssignmentsResponse, error)
	UpdateAssignment(ctx context.Context, in *UpdateAssignmentRequest, opts ...grpc.CallOption) (*AssignmentResponse, error)
	DeleteAssignment(ctx context.Context, in *DeleteAssignmentRequest, opts ...grpc.CallOption) (*DeleteAssignmentResponse, error)
}

type assignmentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAssignmentServiceClient(cc grpc.ClientConnInterface) AssignmentServiceClient {
	return &assignmentServiceClient{cc}
}

func (c *assignmentServiceClient) CreateAssignment(ctx context.Context, in *CreateAssignmentRequest, opts ...grpc.CallOption) (*AssignmentResponse, error) {
	out := new(AssignmentResponse)
	err := c.cc.Invoke(ctx, "/talytics.AssignmentService/CreateAssignment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assignmentServiceClient) GetAssignment(ctx context.Context, in *GetAssignmentRequest, opts ...grpc.CallOption) (*AssignmentResponse, error) {
	out := new(AssignmentResponse)
	err := c.cc.Invoke(ctx, "/talytics.AssignmentService/GetAssignment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assignmentServiceClient) ListAssignments(ctx context.Context, in *ListAssignmentsRequest, opts ...grpc.CallOption) (*ListAssignmentsResponse, error) {
	out := new(ListAssignmentsResponse)
	err := c.cc.Invoke(ctx, "/talytics.AssignmentService/ListAssignments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assignmentServiceClient) UpdateAssignment(ctx context.Context, in *UpdateAssignmentRequest, opts ...grpc.CallOption) (*AssignmentResponse, error) {
	out := new(AssignmentResponse)
	err := c.cc.Invoke(ctx, "/talytics.AssignmentService/UpdateAssignment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assignmentServiceClient) DeleteAssignment(ctx context.Context, in *DeleteAssignmentRequest, opts ...grpc.CallOption) (*DeleteAssignmentResponse, error) {
	out := new(DeleteAssignmentResponse)
	err := c.cc.Invoke(ctx, "/talytics.AssignmentService/DeleteAssignment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AssignmentServiceServer is the server API for AssignmentService service.
// All implementations must embed UnimplementedAssignmentServiceServer
// for forward compatibility
type AssignmentServiceServer interface {
	CreateAssignment(context.Context, *CreateAssignmentRequest) (*AssignmentResponse, error)
	GetAssignment(context.Context, *GetAssignmentRequest) (*AssignmentResponse, error)
	ListAssignments(context.Context, *ListAssignmentsRequest) (*ListAssignmentsResponse, error)
	UpdateAssignment(context.Context, *UpdateAssignmentRequest) (*AssignmentResponse, error)
	DeleteAssignment(context.Context, *DeleteAssignmentRequest) (*DeleteAssignmentResponse, error)
	mustEmbedUnimplementedAssignmentServiceServer()
}

// UnimplementedAssignmentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAssignmentServiceServer struct {
}

func (UnimplementedAssignmentServiceServer) CreateAssignment(context.Context, *CreateAssignmentRequest) (*AssignmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAssignment not implemented")
}
func (UnimplementedAssignmentServiceServer) GetAssignment(context.Context, *GetAssignmentRequest) (*AssignmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAssignment not implemented")
}
func (UnimplementedAssignmentServiceServer) ListAssignments(context.Context, *ListAssignmentsRequest) (*ListAssignmentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAssignments not implemented")
}
func (UnimplementedAssignmentServiceServer) UpdateAssignment(context.Context, *UpdateAssignmentRequest) (*AssignmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAssignment not implemented")
}
func (UnimplementedAssignmentServiceServer) DeleteAssignment(context.Context, *DeleteAssignmentRequest) (*DeleteAssignmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAssignment not implemented")
}
func (UnimplementedAssignmentServiceServer) mustEmbedUnimplementedAssignmentServiceServer() {}

// UnsafeAssignmentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AssignmentServiceServer will
// result in compilation errors.
type UnsafeAssignmentServiceServer interface {
	mustEmbedUnimplementedAssignmentServiceServer()
}

func RegisterAssignmentServiceServer(s grpc.ServiceRegistrar, srv AssignmentServiceServer) {
	s.RegisterService(&AssignmentService_ServiceDesc, srv)
}

func _AssignmentService_CreateAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAssignmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignmentServiceServer).CreateAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.AssignmentService/CreateAssignment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignmentServiceServer).CreateAssignment(ctx, req.(*CreateAssignmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssignmentService_GetAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAssignmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignmentServiceServer).GetAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.AssignmentService/GetAssignment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignmentServiceServer).GetAssignment(ctx, req.(*GetAssignmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssignmentService_ListAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAssignmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignmentServiceServer).ListAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.AssignmentService/ListAssignments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignmentServiceServer).ListAssignments(ctx, req.(*ListAssignmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssignmentService_UpdateAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAssignmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignmentServiceServer).UpdateAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.AssignmentService/UpdateAssignment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignmentServiceServer).UpdateAssignment(ctx, req.(*UpdateAssignmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssignmentService_DeleteAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAssignmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignmentServiceServer).DeleteAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.AssignmentService/DeleteAssignment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignmentServiceServer).DeleteAssignment(ctx, req.(*DeleteAssignmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AssignmentService_ServiceDesc is the grpc.ServiceDesc for AssignmentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AssignmentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "talytics.AssignmentService",
	HandlerType: (*AssignmentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAssignment",
			Handler:    _AssignmentService_CreateAssignment_Handler,
		},
		{
			MethodName: "GetAssignment",
			Handler:    _AssignmentService_GetAssignment_Handler,
		},
		{
			MethodName: "ListAssignments",
			Handler:    _AssignmentService_ListAssignments_Handler,
		},
		{
			MethodName: "UpdateAssignment",
			Handler:    _AssignmentService_UpdateAssignment_Handler,
		},
		{
			MethodName: "DeleteAssignment",
			Handler:    _AssignmentService_DeleteAssignment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talytics.proto",
}

// RubricServiceClient is the client API for RubricService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RubricServiceClient interface {
	CreateRubric(ctx context.Context, in *CreateRubricRequest, opts ...grpc.CallOption) (*RubricResponse, error)
	GetRubric(ctx context.Context, in *GetRubricRequest, opts ...grpc.CallOption) (*RubricResponse, error)
	ListRubrics(ctx context.Context, in *ListRubricsRequest, opts ...grpc.CallOption) (*ListRubricsResponse, error)
	UpdateRubric(ctx context.Context, in *UpdateRubricRequest, opts ...grpc.CallOption) (*RubricResponse, error)
	DeleteRubric(ctx context.Context, in *DeleteRubricRequest, opts ...grpc.CallOption) (*DeleteRubricResponse, error)
}

type rubricServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRubricServiceClient(cc grpc.ClientConnInterface) RubricServiceClient {
	return &rubricServiceClient{cc}
}

func (c *rubricServiceClient) CreateRubric(ctx context.Context, in *CreateRubricRequest, opts ...grpc.CallOption) (*RubricResponse, error) {
	out := new(RubricResponse)
	err := c.cc.Invoke(ctx, "/talytics.RubricService/CreateRubric", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubricServiceClient) GetRubric(ctx context.Context, in *GetRubricRequest, opts ...grpc.CallOption) (*RubricResponse, error) {
	out := new(RubricResponse)
	err := c.cc.Invoke(ctx, "/talytics.RubricService/GetRubric", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubricServiceClient) ListRubrics(ctx context.Context, in *ListRubricsRequest, opts ...grpc.CallOption) (*ListRubricsResponse, error) {
	out := new(ListRubricsResponse)
	err := c.cc.Invoke(ctx, "/talytics.RubricService/ListRubrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubricServiceClient) UpdateRubric(ctx context.Context, in *UpdateRubricRequest, opts ...grpc.CallOption) (*RubricResponse, error) {
	out := new(RubricResponse)
	err := c.cc.Invoke(ctx, "/talytics.RubricService/UpdateRubric", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubricServiceClient) DeleteRubric(ctx context.Context, in *DeleteRubricRequest, opts ...grpc.CallOption) (*DeleteRubricResponse, error) {
	out := new(DeleteRubricResponse)
	err := c.cc.Invoke(ctx, "/talytics.RubricService/DeleteRubric", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RubricServiceServer is the server API for RubricService service.
// All implementations must embed UnimplementedRubricServiceServer
// for forward compatibility
type RubricServiceServer interface {
	CreateRubric(context.Context, *CreateRubricRequest) (*RubricResponse, error)
	GetRubric(context.Context, *GetRubricRequest) (*RubricResponse, error)
	ListRubrics(context.Context, *ListRubricsRequest) (*ListRubricsResponse, error)
	UpdateRubric(context.Context, *UpdateRubricRequest) (*RubricResponse, error)
	DeleteRubric(context.Context, *DeleteRubricRequest) (*DeleteRubricResponse, error)
	mustEmbedUnimplementedRubricServiceServer()
}

// UnimplementedRubricServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRubricServiceServer struct {
}

func (UnimplementedRubricServiceServer) CreateRubric(context.Context, *CreateRubricRequest) (*RubricResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRubric not implemented")
}
func (UnimplementedRubricServiceServer) GetRubric(context.Context, *GetRubricRequest) (*RubricResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRubric not implemented")
}
func (UnimplementedRubricServiceServer) ListRubrics(context.Context, *ListRubricsRequest) (*ListRubricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRubrics not implemented")
}
func (UnimplementedRubricServiceServer) UpdateRubric(context.Context, *UpdateRubricRequest) (*RubricResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRubric not implemented")
}
func (UnimplementedRubricServiceServer) DeleteRubric(context.Context, *DeleteRubricRequest) (*DeleteRubricResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRubric not implemented")
}
func (UnimplementedRubricServiceServer) mustEmbedUnimplementedRubricServiceServer() {}

// UnsafeRubricServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RubricServiceServer will
// result in compilation errors.
type UnsafeRubricServiceServer interface {
	mustEmbedUnimplementedRubricServiceServer()
}

func RegisterRubricServiceServer(s grpc.ServiceRegistrar, srv RubricServiceServer) {
	s.RegisterService(&RubricService_ServiceDesc, srv)
}

func _RubricService_CreateRubric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRubricRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubricServiceServer).CreateRubric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.RubricService/CreateRubric",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubricServiceServer).CreateRubric(ctx, req.(*CreateRubricRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubricService_GetRubric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRubricRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubricServiceServer).GetRubric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.RubricService/GetRubric",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubricServiceServer).GetRubric(ctx, req.(*GetRubricRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubricService_ListRubrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRubricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubricServiceServer).ListRubrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.RubricService/ListRubrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubricServiceServer).ListRubrics(ctx, req.(*ListRubricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubricService_UpdateRubric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRubricRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubricServiceServer).UpdateRubric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.RubricService/UpdateRubric",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubricServiceServer).UpdateRubric(ctx, req.(*UpdateRubricRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubricService_DeleteRubric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRubricRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubricServiceServer).DeleteRubric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.RubricService/DeleteRubric",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubricServiceServer).DeleteRubric(ctx, req.(*DeleteRubricRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RubricService_ServiceDesc is the grpc.ServiceDesc for RubricService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RubricService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "talytics.RubricService",
	HandlerType: (*RubricServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRubric",
			Handler:    _RubricService_CreateRubric_Handler,
		},
		{
			MethodName: "GetRubric",
			Handler:    _RubricService_GetRubric_Handler,
		},
		{
			MethodName: "ListRubrics",
			Handler:    _RubricService_ListRubrics_Handler,
		},
		{
			MethodName: "UpdateRubric",
			Handler:    _RubricService_UpdateRubric_Handler,
		},
		{
			MethodName: "DeleteRubric",
			Handler:    _RubricService_DeleteRubric_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talytics.proto",
}

// GradeServiceClient is the client API for GradeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GradeServiceClient interface {
	UploadGrades(ctx context.Context, in *UploadGradesRequest, opts ...grpc.CallOption) (*UploadGradesResponse, error)
	GetGradeStats(ctx context.Context, in *GetGradeStatsRequest, opts ...grpc.CallOption) (*GetGradeStatsResponse, error)
	GetGradeDistribution(ctx context.Context, in *GetGradeDistributionRequest, opts ...grpc.CallOption) (*GetGradeDistributionResponse, error)
}

type gradeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGradeServiceClient(cc grpc.ClientConnInterface) GradeServiceClient {
	return &gradeServiceClient{cc}
}

func (c *gradeServiceClient) UploadGrades(ctx context.Context, in *UploadGradesRequest, opts ...grpc.CallOption) (*UploadGradesResponse, error) {
	out := new(UploadGradesResponse)
	err := c.cc.Invoke(ctx, "/talytics.GradeService/UploadGrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gradeServiceClient) GetGradeStats(ctx context.Context, in *GetGradeStatsRequest, opts ...grpc.CallOption) (*GetGradeStatsResponse, error) {
	out := new(GetGradeStatsResponse)
	err := c.cc.Invoke(ctx, "/talytics.GradeService/GetGradeStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gradeServiceClient) GetGradeDistribution(ctx context.Context, in *GetGradeDistributionRequest, opts ...grpc.CallOption) (*GetGradeDistributionResponse, error) {
	out := new(GetGradeDistributionResponse)
	err := c.cc.Invoke(ctx, "/talytics.GradeService/GetGradeDistribution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GradeServiceServer is the server API for GradeService service.
// All implementations must embed UnimplementedGradeServiceServer
// for forward compatibility
type GradeServiceServer interface {
	UploadGrades(context.Context, *UploadGradesRequest) (*UploadGradesResponse, error)
	GetGradeStats(context.Context, *GetGradeStatsRequest) (*GetGradeStatsResponse, error)
	GetGradeDistribution(context.Context, *GetGradeDistributionRequest) (*GetGradeDistributionResponse, error)
	mustEmbedUnimplementedGradeServiceServer()
}

// UnimplementedGradeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGradeServiceServer struct {
}

func (UnimplementedGradeServiceServer) UploadGrades(context.Context, *UploadGradesRequest) (*UploadGradesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadGrades not implemented")
}
func (UnimplementedGradeServiceServer) GetGradeStats(context.Context, *GetGradeStatsRequest) (*GetGradeStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGradeStats not implemented")
}
func (UnimplementedGradeServiceServer) GetGradeDistribution(context.Context, *GetGradeDistributionRequest) (*GetGradeDistributionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGradeDistribution not implemented")
}
func (UnimplementedGradeServiceServer) mustEmbedUnimplementedGradeServiceServer() {}

// UnsafeGradeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GradeServiceServer will
// result in compilation errors.
type UnsafeGradeServiceServer interface {
	mustEmbedUnimplementedGradeServiceServer()
}

func RegisterGradeServiceServer(s grpc.ServiceRegistrar, srv GradeServiceServer) {
	s.RegisterService(&GradeService_ServiceDesc, srv)
}

func _GradeService_UploadGrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadGradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GradeServiceServer).UploadGrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.GradeService/UploadGrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GradeServiceServer).UploadGrades(ctx, req.(*UploadGradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GradeService_GetGradeStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGradeStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GradeServiceServer).GetGradeStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.GradeService/GetGradeStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GradeServiceServer).GetGradeStats(ctx, req.(*GetGradeStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GradeService_GetGradeDistribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGradeDistributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GradeServiceServer).GetGradeDistribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.GradeService/GetGradeDistribution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GradeServiceServer).GetGradeDistribution(ctx, req.(*GetGradeDistributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GradeService_ServiceDesc is the grpc.ServiceDesc for GradeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GradeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "talytics.GradeService",
	HandlerType: (*GradeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadGrades",
			Handler:    _GradeService_UploadGrades_Handler,
		},
		{
			MethodName: "GetGradeStats",
			Handler:    _GradeService_GetGradeStats_Handler,
		},
		{
			MethodName: "GetGradeDistribution",
			Handler:    _GradeService_GetGradeDistribution_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talytics.proto",
}

// AnalysisServiceClient is the client API for AnalysisService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AnalysisServiceClient interface {
	RunAnomalyAnalysis(ctx context.Context, in *RunAnomalyAnalysisRequest, opts ...grpc.CallOption) (*AnomalyAnalysisResponse, error)
	GetAnalysisHistory(ctx context.Context, in *GetAnalysisHistoryRequest, opts ...grpc.CallOption) (*GetAnalysisHistoryResponse, error)
}

type analysisServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAnalysisServiceClient(cc grpc.ClientConnInterface) AnalysisServiceClient {
	return &analysisServiceClient{cc}
}

func (c *analysisServiceClient) RunAnomalyAnalysis(ctx context.Context, in *RunAnomalyAnalysisRequest, opts ...grpc.CallOption) (*AnomalyAnalysisResponse, error) {
	out := new(AnomalyAnalysisResponse)
	err := c.cc.Invoke(ctx, "/talytics.AnalysisService/RunAnomalyAnalysis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analysisServiceClient) GetAnalysisHistory(ctx context.Context, in *GetAnalysisHistoryRequest, opts ...grpc.CallOption) (*GetAnalysisHistoryResponse, error) {
	out := new(GetAnalysisHistoryResponse)
	err := c.cc.Invoke(ctx, "/talytics.AnalysisService/GetAnalysisHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnalysisServiceServer is the server API for AnalysisService service.
// All implementations must embed UnimplementedAnalysisServiceServer
// for forward compatibility
type AnalysisServiceServer interface {
	RunAnomalyAnalysis(context.Context, *RunAnomalyAnalysisRequest) (*AnomalyAnalysisResponse, error)
	GetAnalysisHistory(context.Context, *GetAnalysisHistoryRequest) (*GetAnalysisHistoryResponse, error)
	mustEmbedUnimplementedAnalysisServiceServer()
}

// UnimplementedAnalysisServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAnalysisServiceServer struct {
}

func (UnimplementedAnalysisServiceServer) RunAnomalyAnalysis(context.Context, *RunAnomalyAnalysisRequest) (*AnomalyAnalysisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunAnomalyAnalysis not implemented")
}
func (UnimplementedAnalysisServiceServer) GetAnalysisHistory(context.Context, *GetAnalysisHistoryRequest) (*GetAnalysisHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAnalysisHistory not implemented")
}
func (UnimplementedAnalysisServiceServer) mustEmbedUnimplementedAnalysisServiceServer() {}

// UnsafeAnalysisServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AnalysisServiceServer will
// result in compilation errors.
type UnsafeAnalysisServiceServer interface {
	mustEmbedUnimplementedAnalysisServiceServer()
}

func RegisterAnalysisServiceServer(s grpc.ServiceRegistrar, srv AnalysisServiceServer) {
	s.RegisterService(&AnalysisService_ServiceDesc, srv)
}

func _AnalysisService_RunAnomalyAnalysis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunAnomalyAnalysisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalysisServiceServer).RunAnomalyAnalysis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.AnalysisService/RunAnomalyAnalysis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalysisServiceServer).RunAnomalyAnalysis(ctx, req.(*RunAnomalyAnalysisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnalysisService_GetAnalysisHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAnalysisHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalysisServiceServer).GetAnalysisHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.AnalysisService/GetAnalysisHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalysisServiceServer).GetAnalysisHistory(ctx, req.(*GetAnalysisHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AnalysisService_ServiceDesc is the grpc.ServiceDesc for AnalysisService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AnalysisService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "talytics.AnalysisService",
	HandlerType: (*AnalysisServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunAnomalyAnalysis",
			Handler:    _AnalysisService_RunAnomalyAnalysis_Handler,
		},
		{
			MethodName: "GetAnalysisHistory",
			Handler:    _AnalysisService_GetAnalysisHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talytics.proto",
}

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthServiceClient interface {
	Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, "/talytics.HealthService/Check", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility
type HealthServiceServer interface {
	Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHealthServiceServer struct {
}

func (UnimplementedHealthServiceServer) Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talytics.HealthService/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).Check(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "talytics.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _HealthService_Check_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talytics.proto",
}
